MSX-DOS 2.50 alpha 1 new function calls and error codes


This document describes the changes in function calls and the new function calls introduced in MSX-DOS 2.50 alpha 1, relative to MSX-DOS 2.20 and MSX-DOS 2.31. Also, the new error codes defined are explained.

NOTE: This information is provisional. MSX-DOS 2.50 is still under development.


    1. Changes in existing function calls

Some of the existing DOS function calls have been modified, mainly to account for the new support for the FAT16 filesystem and 23 bit sector numbers. These changes are non breaking to the extent possible.


    * STROUT (09h)

When the fast STROUT mode is enabled, the maximum printable string length is 511 characters; if the string is longer, only the first 511 characters will be printed. The fast STROUT mode is disabled by default, it must be explicitly enabled by using the new FOUT function.


    * ALLOC (1Bh)

When the reduced allocation information mode is enabled for a drive, this function will return a false total and/or free cluster count when necessary so that when multiplied by the sectors per cluster amount, the result will give 32MBytes or less when called for that drive. The reduced allocation information mode is disabled by default for all drives, it must be explicitly enabled for each desired drive by using the new RALLOC function.


    * RDABS (2Fh) and WRABS (30h)

These functions will work only when the accessed disk contains a FAT12 filesystem. They will throw a "Not a DOS disk" when a disk containing a FAT16 filesystem or an unknown filesystem is accessed.

Strictly speaking, this is not a change from previous versions, since FAT12 was the only filesystem supported by MSX-DOS 2.31 and previous versions. However, when a disk containing a FAT16 filesystem was read in previous MSX-DOS versions, its boot sector was mistook for a FAT12 boot sector, and the functions succeeded. Now FAT16 disks are explicitly rejected by these functions; this is done on purpose to prevent programs, such as CHKDSK or IMPROVE, that do low-level processing on disks assuming that they have a FAT12 filesystem, to cause data corruption when accidentally ran on these disks.

New applications should use instead the new functions RDDRV and WRDRV, which accept 32 bit sector numbers and allow acces to any disk regardless of the contained filesystem.


    * DPARM (31h)

This function now returns the total number of logical sectors as a 32 bit value at position +24..27 in the returned parameter block. Moreover, when this number is greater than 65535, the 16 bit sector count returned at position +9,10 will be zero.

Also, position +28 of the returned parameter block contains the filesystem type:

0: FAT12
1: FAT16
2: FAT32 (for direct filesystem access mode)
255: Other (for direct filesystem access mode)


    * DEFER (64h)

The parameters passed to the user routine in case of disk error are extended to support 32 bit sector numbers. In MSX-DOS 2.31, part of these parameters were as follows:

    C:b3 - set if sector number is valid
    DE = Sector number (if b3 of C is set)

In MSX-DOS 2.50, these parameters are:

    C:b3 - set if sector number is valid and fits in 16 bits (that is, b4 is set and HL=0)
    C:b4 - set if sector number is valid
    HL:DE = Sector number (if b4 of C is set)


    * FORMAT (67h)

In MSX-DOS 2.31, this function accepts two special choice parameters, FFh and FEh, that do not actually format the disk but generate a MSX-DOS 2.31 boot sector, including the disk parameters, based on the media ID of the disk. This feature is used by the FIXDISK program to convert old MSX-DOS 1 disks into MSX-DOS 2 disks.

MSX-DOS 2.50 adds three new choice parameters:

    FDh: Assuming that the disk has a FAT12 or FAT16 filesystem with valid disk parameters on the boot sector (otherwise a "Not a DOS disk" will be returned), a standard boot sector will be composed for the disk by (1) setting the manufacturer name as "MSXDOS25", and (2) generating an extended block (byte 29h, plus volume ID, plus volume name, plus "FAT12" or "FAT16" mark). The disk parameters will not be modified. If the disk contains an extended block already, only the manufacturer name will be changed (thus mantaining the existing volume ID). This choice is useful for using the dirty disk flag feature on disks already formatted by another system.

    FCh: It is the same as FDh, but if the disk filesystem is FAT12, a MSX-DOS 2.31 boot sector (with the "VOL_ID" string) will be composed instead of a standard boot sector. If the disk filesystem is FAT16, this choice works the same way as FDh. This choice is useful if the disk is to be used on pre-2.50 MSX-DOS 2 systems.

    FBh: Will do a "quick format" on the disk, by simply clearing the FAT and root directory areas. As with the other two new choices, the disk must have a valid FAT12 or FAT16 boot sector, otherwise a "Not a DOS disk" error will be returned. 

When the disk is actually formatted (choice 1..9), a MSX-DOS 2.31 boot sector will always be generated.


    * DOSVER (6Fh)

Now HL returns a pointer to a zero-terminated printable string that describes the kernel version, for example "MSX-DOS 2.50". The string resides in the kernel master slot (slot number is available at 0F348h) and can be readed via standard RDSLT calls.


    2. New function calls

The following functions are new to MSX-DOS 2.50:


    * Get/set fast STROUT mode

Parameters:    C = 71H (_FOUT)
               A = 00H => get fast STROUT mode
                   01H => set fast STROUT mode
               B = 00H => disable (only if A=01H)
                   FFH => enable (only if A=01H)
Results:       A = Error
               B = Current fast STROUT mode

This function enables or disables the fast STROUT mode. When enabled, STROUT and ZSTROUT functions will work faster, but the maximum printable string length will be 511 characters; if the string is longer, only the first 511 characters will be printed.


    * Print a zero-terminated string

Parameters:    C = 72H (_ZSTROUT)
               DE = Address of string
Results:       A = 0 (never returns an error)

Prints on the screen the string pointed by DE, the string must be terminated with a zero character. This function is affected by the fast STROUT mode.


    * Read absolute sectors from drive

Parameters:    C = 73H (_RDDRV)
               A = Drive number (0=A: etc.)
               B = Number of sectors to read
              HL:DE = Sector number
Results:       A = Error code (0=> no error)

This function reads sectors directly from the disk. Unlike RDABS, this function is able to read sectors regardless of the filesystem contained in the disk (FAT12, FAT16 or an unknown filesystem), and even when the disk has no filesystem at all. The sectors will be read to the current disk transfer address. Any disk error will be reported by the system in the usual way.


    * Write absolute sectors to drive

Parameters:    C = 74H (_WRDRV)
               A = Drive number (0=A: etc.)
               B = Number of sectors to write
              HL:DE = Sector number
Results:       A = Error code (0=> no error)

This function writes sectors directly to the disk. Unlike WRABS, this function is able to write sectors regardless of the filesystem contained in the disk (FAT12, FAT16 or an unknown filesystem), and even when the disk has no filesystem at all. The sectors will be written from the current disk transfer address. Any disk error will be reported by the system in the usual way.


    * Get/set reduced allocation information mode vector

Parameters:    C = 75H (_RALLOC)
               A = 00H => get current vector
                   01H => set vector
               HL = new vector (only if A=01H)
Results:       A = 0 (never returns an error)
               HL = Current vector

This function obtains or sets the reduced allocation information mode vector. The vector assigns one bit for each drive; bit 0 of L is for A:, bit 1 of L is for B:, etc. This bit is 1 if the reduced allocation mode is currently enabled (when getting vector) or to be enabled (when setting vector) for the drive, 0 when the mode is disabled or to be disabled.


    * Get disk space information

Parameters:    C = 76H (_DSPACE)
               E = drive number (0 = default, 1 = A:, etc)
               A = 00H => get free space
                   01H => get total space
Results:       A = error code
               HL:DE = space in Kilobytes
               BC = extra free space in bytes

This function returns the total or free space for a disk. The space information is always returned in Kilobytes, regardless of the filesystem and the cluster size used by the disk.

The "extra free space in bytes" result will be different from zero only when the minimum allocation unit of the disk is not a whole number of kilobytes. In case of FAT disks, it will be non zero (specifically, it will be 512) only when the disk uses one sector per cluster and the cluster count is odd. For example, for a disk having one sector per cluster and 15 free clusters, this function will return HL=0, DE=7 and BC=512 when called with A=0 for that disk.

The space information returned by this function is always real, it is not affected by the reduced allocation information mode.


    * Mount/unmount a disk, or get mount state for a disk

Parameters:    C = 77H (_MOUNT)
               E = physical drive (0=A:, 1=B:, etc)
               A = 00H => get mount status
                   01H => set mount status
               B = 00H => unmount disk (only if A=01H)
                   FFH => mount disk (only if A=01H)
Results:       A = Error code
               B = Current mount status, same as input

This function mounts or unmounts a disk, or gets the current mount state for a disk. When a disk is mounted, MSX-DOS will assume that the disk will never be changed, and therefore will never ask the disk driver for disk change status; thus resulting in an overall increase on disk access speed. This is useful when using removable devices, such as multimedia cards, as the main storage device.

In order to be mounted, the disk must be in the drive and must be a valid DOS disk; otherwise an error will be thrown and the disk will not be mounted.

Once a disk is mounted, any disk error that is aborted will automatically unmount the disk.

Mounting and unmounting operations cause all the buffers for the disk to be flushed and invalidated. Also, cached disk parameters for the disk are deleted so the next access to the disk will re-read them.

It is possible to mount non-removable devices associated to device-based drivers, however it makes no sense to do that, since MSX-DOS will never ask for disk change status for this kind of devices.

Mounting feature must be used with care. Changing a mounted disk without first unmounting it may result in disk corruption, both in the original (mounted) disk and in the newly inserted disk.


    * Get information about a disk driver

Parameters:    C = 78H (_GDRVR)
               A = Driver index, or 0 to specify slot and segment
               D = Driver slot number (only if A=0)
               E = Driver segment number, FFh for drivers in ROM
                   (only if A=0)
               HL = Pointer to 64 byte data buffer
Results:       A = Error code
               HL = Filled with data about driver

This function returns information about a disk driver present in the system.

The disk driver can be specified by index or by slot and segment number pair. To specify the driver by index, set the index number (starting at 1) in register A; the slot and segment number for the driver is returned in the data buffer together with other driver information. This is useful to discover which drivers are present in the system.

If you know already the slot and segment numbers of the driver you want to gather information about, set these parameters in registers D and E, and set A=0. The slot and segment numbers are returned anyway in the data buffer, as in the case of specifying a driver index.

An .IDRVR error will be returned if there is no driver associated to the specified index, or if there is no driver with the specified slot and segment pair. There is no way to know in advance how many drivers are present in the system, so to discover all the drivers this function must be invoked several times, starting with driver index 1 and increasing the index number until a .IDRVR error is obtained.

The information returned in the data buffer is as follows:

HL+0: Driver slot number
HL+1: Driver segment number, FFh if the driver is embedded within a MSX-DOS kernel ROM (always FFh in alpha 1)
HL+2: Number of drive letters assigned to this driver at boot time
HL+3: First drive letter assigned to this driver at boot time (A:=0, etc), unused if no drives are assigned at boot time
HL+4: Driver flags:
      bit 7: 1 => the driver is a MSX-DOS 2.50 driver
             0 => the driver is a legacy driver
                  (embedded within a MSX-DOS 1/2.20/2.3x kernel ROM)
      bits 6-2: Unused, always zero
      bit 1: 1 => the driver supports hot-plug devices (not implemented in alpha 1)
             0 => the driver does NOT support hot-plug devices
      bit 0: 1 => the driver is a device-based driver
             0 => the driver is a drive-based driver
HL+5: Driver main version number
HL+6: Driver secondary version number
HL+7: Driver revision number
HL+8: Driver name, left justified, padded with spaces (32 bytes)
HL+40..+63: Reserved (currently always zero)

In the case of legacy drivers, the driver flags byte is always zero, and no information about driver version number or driver name is returned.


    * Get information about a drive letter

Parameters:    C = 79H (_GDLI)
               A = physical drive (0=A:, 1=B:, etc)
               HL = Pointer to 64 byte data buffer
Results:       A = Error code
               HL = Filled with data about the drive

This function return information about a given drive letter. The information returned in the data buffer is as follows:

HL+0: Drive status
      0: Unassigned
      1: Assigned to a ROM or RAM driver in block device mode
      2: Assigned to a ROM or RAM driver in direct access mode (not supported in alpha 1)
      3: Assigned to a mounted file (not supported in alpha 1)
      4: Assigned to the MSX-DOS 2 RAM disk (all other fields will be zero then)
HL+1: Driver slot number
HL+2: Driver segment number, FFh if the driver is embedded within a MSX-DOS kernel ROM
HL+3: Relative drive number withing the driver (for drive-based drivers only; FFh if device-based driver)
HL+4: Device index (for device-based drivers only; 0 for drive-based drivers and legacy drivers)
HL+5: Logical unit index (for device-based drivers only; 0 for drive-based drivers and legacy drivers)
HL+5..+8: First device sector number (for block devices in device-based drivers only; always zero for drive-based drivers, legacy drivers, and non-block devices)
HL+9..+22: Filename, zero-terminated (null string if not assigned to a mounted file)
HL+22..+63: Reserved (currently always zero)

If a drive larger than the maximum drive number supported by the system is specified, an .IDRV error will be returned. Note that if a drive number is specified which is legal in MSX-DOS, but is currently not assigned to any driver, then no error will be returned, but an empty information block will be returned (the drive status byte should be checked).

The "first device sector number" is the absolute device sector number that is treated as the first logical sector for the drive; usually it is either the starting sector of a disk partition, or the device absolute sector zero, if the device has no partitions. Note that you can't test this value against zero to check whether the drive is assigned to a block device on a device-based driver or not.

When a file is mounted in the drive, the filename only will be returned in HL+9; no drive or path information for the file will be obtained.


    * Get information about a disk partition

Parameters:    C = 7AH (_GPART)
               A = Driver slot number
               B = Driver segment number, FFh for drivers in ROM
               D = Device index
               E = Logical unit index
               H = Primary partition number (1 to 4)
               L = Extended partition number (0 for an entry in the primary partition table)
Results:       A = Error code
               B = Partition type code, 0 if the specified partition does not exist
               HLDE = Starting device absolute sector number of the partition

This function returns information about a disk partition. It only works on device-based drivers; if a non existing driver, a drive-based driver, or a legacy driver is specified in A and B, then an .IDRVR error will be returned. If the specified device and/or logical unit does not exist in the driver, an .IDEVL error will be returned.

Block devices are usually divided in partitions, each one being an independent logical volume residing in a contiguous block of sectors in the disk. This function allows to find the starting sector of a given partition in the disk, usually in order to map it to a drive letter by using the MAPDRV function, so that the contained filesystem can be accessed by MSX-DOS.

The partition type code returns information about the filesystem that the partition holds. The code may be one of the following:

0: None (the partition with the specified number does not exist)
1: FAT12
4: FAT16, smaller than 32MB (obsolete)
5: Extended (see below)
6: FAT16

There are many more partition type codes defined, but they refer to filesystems that can't be handled by MSX-DOS so they are not listed here.

A disk can have up to four primary partitions, numbered 1 to 4. In order to accommodate more than four partitions, partition number 2 may be of a special type named "Extended". An extended partition is actually a container for more partitions; there is no limit in the number of extra partitions that a partition of type "Extended" can contain. Primary partitions 3 and 4 do not exist when partition 2 is extended.

In order to enumerate all the partitions existing in a disk, the following procedure should be followed, to take in account the possible presence of extended partitions:

1. Search partition 1-0 (primary number 1, extended number 0).
2. Search partition 2-0. If it exists and is of type "Extended", search partitions 2-1, 2-2, 2-3, etc, until a partition code 0 is returned.
3. If partition 2-0 does not exits or is not of type "Extended", search partitions 3-0 and 3-4.

Note that it is possible that a device has no partitions at all. In this case, it is still possible that the disk contains a valid filesystem, mapped to the absolute device sector zero; this is indeed the case of floppy disks and devices with very small capacity.

When a partition is mapped to a drive letter, the partition first sector will always be examined in order to determine the actual filesystem holded by the partition. MSX-DOS will never rely in the partition type code to determine the filesystem type.

MSX-DOS needs to read the disk in order to search for partitions. If there is any error when accessing the disk (for example, not ready), an error code will be returned. The standard system error handling routine (or the user error handling routine, if one is defined with _DEFER) will NOT be invoked.

When the specified partition does not exist in the disk (for example, when a primary partition number larger than 4 is specified, or when an extended partition number is specified for a non-extended primary partition), then B=0 and A=.IPART will be returned.


    * Call a routine in a disk driver

Parameters:    C = 7BH (_CDRVR)
               A = Driver slot number
               B = Driver segment number, FFh for drivers in ROM
               DE = Routine address
               HL = Address of a 8 byte buffer with the input register values for the routine
Results:       A = Error code
               BC, DE, HL = Results from the routine
               IX = Value of AF returned by the routine

This function allows direct invokation of a routine in a disk driver. Routines for any driver type (legacy, device-based and drive-based) can be invoked with this function, however it is intended primarily for device-based drivers, in order to directly access the device absolute sectors (DEV_RW routine), for example to develop disk partitioning tools. The available routines for disk drivers are enumerated and described in detail in the Driver Development Guide.

The input value of registers AF, BC, DE and HL for the routine must be provided in a 8 byte buffer pointed by HL. The order of the register values in the buffer is as follows: F, A, C, B, E, D, L, H. The output values of these registers, on the other hand, are returned directly in the registers themselves; except the output value of AF which is returned in IX.

Some routines accept data from, or write data to, memory buffers supplied by the user. There are two limitations for exchanging data with the driver routines in this way: first, the buffer must be in the primary mapper slot; and second, the buffer may not be partially or totally in page-1. These limitations do not apply for the 8 byte register buffer (remember however that when invoking MSX-DOS function calls via the 0F37Dh hook, no parameters can be passed in page-1). The register buffer is only used before effectively executing the driver routine, therefore there is no problem if it overlaps with any buffer used by the routine to return data.

An .IDRVR error will be returened by this function call if a non existing driver is supplied in A and B. Use function GDRVR to discover the location of the existing drivers.


    * Map a drive letter to a driver and device

Parameters:    C = 7CH (_MAPDRV)
               A = physical drive (0=A:, 1=B:, etc)
               B = Action to perform
                   0: Unmap the drive
                   1: Map the drive to its default state
                   2: Map the drive by using specific mapping data
               HL = Address of a 8 byte buffer with mapping data (if B=2)
Results:       A = Error code

This function allows mapping a drive number to a specific combination of device number, logical unit number, and starting absolute device sector number, within a device-based driver. It also allows to revert back the drive mapping to its default state (the state at boot time), and to completely unmap the drive.

If B=0 at input, the drive will be unmapped. This means that the drive will be unavailable from that moment, and any attempt to access it will result in an "Invalid drive" error. If the drive is already unmapped, nothing will happen and no error will be returned.

If B=1 at input, the drive will be reverted to its default state. If at boot time the drive was unmapped (not assigned to any driver), or was mapped to a drive on a legacy driver or on a drive-based driver, then the drive will be reverted to the same state. If at boot time the drive was assigned to a device-based driver, then an auto-assign procedure will be performed for this drive, using the same rules as the auto-assign procedure performed at boot time (see "Drive and partition auto-assign procedure for device-based drivers" early in this document). This may result or not on the drive having the same mapping as it had at boot time, depending on the presence of removable devices and hot-plug devices in the associated driver.

If the auto-assign procedure resulting from invoking this function with B=1 fails (because there are no suitable devices or partitions), the drive will be unmapped, regardless of its previous mapping state. An .IDEVL error will be returned in this case.

If B=2 at input, the drive will be mapped according to the mapping data provided in the buffer pointer by HL. It is possible to map any system drive to any device-based driver by using this method, even drives that were unmapped or were mapped to a different driver at boot time. The contents of the mapping data buffer must be as follows:

+0: Driver slot number
+1: Driver segment number, FFh if the driver is embedded within a MSX-DOS kernel ROM (must be always FFh in alpha 1)
+2: Device number
+3: Logical unit number
+4..+7: Starting sector

An .IDRVR error will be returned if the specified driver does not exists or is not a device-based driver. An .IDEVL error will be returned if the device with the specified device and logical unit numbers does not exists in the driver. In these cases, the previous drive mapping will not be modified.

A .RAMDX error will be returned if the drive specified is H: and a RAM disk exists.

It is not possible to assign the same combination of driver, device, logical unit, and starting sector to more than one drive at the same time; this is to prevent data corruption. If the mapping data provided matches the mapping data of other drive, then a "Partition in use" error will be thrown.

The "starting sector" parameter is the device absolute sector number that will be used as the sector zero for the drive. Usually this will be the starting sector of a disk partition, obtained via a call to the _GPART function. Note however that no checking is done for the presence of an actual (and recognized by MSX-DOS) filesystem starting in the specified sector; if no valid filesystem is found, the _MAPDRV function will succeed, but the next access to the drive will throw a "Not a DOS disk" error.

Also, it is possible to map a drive to a removable device which has no media inserted. In this case, the _MAPDRV function will succeed, but the next access to the drive will throw a "Disk offline" error.

It is not possible to map two drives to the same combination of driver, device, logical unit, and start sector; this is to prevent data corruption resulting from dealing with unsynchronized disk buffers. An .IDEVL error will be throw in this case. In order to change the drive letter for a given mapping, the old drive letter must be first unmapped.

Also, note that it is not possible to explicitly map a drive to a legacy or drive-based driver.

Before changing the mapping state of a drive, any open file handles relative to that drive will be closed by this function. This is equivalent to invoking the CLOSE function call for each of these file handles, so disk errors may arise if there are dirty buffers for that disk and there are errors when flushing them to the disk.


    * Enable or disable the Z80 access mode for a legacy driver

Parameters:    C = 7DH (_Z80MODE)
               A = Driver slot number
               B = 00H => get current Z80 access mode
                   01H => set Z80 access mode
               D = 00H => disable Z80 access mode (only if A=01H)
                   FFH => enable Z80 access mode (only if A=01H)
Results:       A = Error code
               D = Current Z80 access mode for the specified driver, same as input

This function works on MSX Turbo-R computers only. On MSX1/2/2+ it will always throw an "Invalid disk driver" error.

This function allows to enable or disable the Z80 access mode for a legacy driver (a driver embedded within a MSX-DOS 1/2.20/2.3x kernel ROM). When the Z80 access mode for a driver is enabled, MSX-DOS will switch to the Z80 CPU prior to accessing any drive associated to the driver. When the Z80 access mode for a driver is disabled, no CPU switching is performed, being therefore possible to access the drives on the driver in R800 mode.

When the computer boots, the Z80 access mode is enabled for all legacy drivers. This is necessary because some old disk drivers do not work when accessed in R800 mode, and it would not be possible to boot from a disk on one of these drivers. Once the system boot has finished, this function can be used to disable (and later re-enable if necessary) the Z80 access mode for any legacy driver.

Note that the Z80 access mode is enabled or disabled for a whole driver, affecting all the drives associated to the driver. It is not possible to selectively enable or disable the Z80 access mode for individual drives.

The Z80 access mode applies to legacy drivers only. MSX-DOS will never change the CPU when accessing drive-based and device-based drivers.


    3. New error codes

New error codes are defined to handle error conditions when managing the new features of MSX-DOS. These errors are the following:


    Invalid device driver (.IDRVR, 0B6h)

An operation involving a disk driver has been requested but the specified driver does not exist, or is not of the valid type (for example, the driver is a legacy driver but a device-based driver is required).


    Invalid device or LUN (.IDEVL, 0B5h)

An operation involving a device on a device-based driver has been requested but the specified device do not exist in the driver, or the specified logical unit does not exist in the specified device.


    Invalid partition number (.IPART, 0B4h)

Information about a disk partition on a device has been requested, but the specified partition does not exist in the device.


    Partition is already in use (.PUSED, 0B3h)

An attempt has made to map a drive to a driver, device and starting sector; but there is already another drive which is mapped to the same combination of driver, device, logical unit, and starting sector.
